/**
 * Clusters of Node.js processes can be used to run multiple instances of Node.js
 * that can distribute workloads among their application threads. When process isolation
 * is not needed, use the [`worker_threads`](https://nodejs.org/docs/latest-v22.x/api/worker_threads.html)
 * module instead, which allows running multiple application threads within a single Node.js instance.
 *
 * The cluster module allows easy creation of child processes that all share
 * server ports.
 *
 * ```js
 * import cluster from 'node:cluster';
 * import http from 'node:http';
 * import { availableParallelism } from 'node:os';
 * import process from 'node:process';
 *
 * const numCPUs = availableParallelism();
 *
 * if (cluster.isPrimary) {
 *   console.log(`Primary ${process.pid} is running`);
 *
 *   // Fork workers.
 *   for (let i = 0; i < numCPUs; i++) {
 *     cluster.fork();
 *   }
 *
 *   cluster.on('exit', (worker, code, signal) => {
 *     console.log(`worker ${worker.process.pid} died`);
 *   });
 * } else {
 *   // Workers can share any TCP connection
 *   // In this case it is an HTTP server
 *   http.createServer((req, res) => {
 *     res.writeHead(200);
 *     res.end('hello world\n');
 *   }).listen(8000);
 *
 *   console.log(`Worker ${process.pid} started`);
 * }
 * ```
 *
 * Running Node.js will now share port 8000 between the workers:
 *
 * ```console
 * $ node server.js
 * Primary 3596 is running
 * Worker 4324 started
 * Worker 4520 started
 * Worker 6056 started
 * Worker 5644 started
 * ```
 *
 * On Windows, it is not yet possible to set up a named pipe server in a worker.
 * @see [source](https://github.com/nodejs/node/blob/v22.x/lib/cluster.js)
 */
declare module "cluster" {
    import * as child from "node:child_process";
    import EventEmitter = require("node:events");
    import * as net from "node:net";
    type SerializationType = "json" | "advanced";
    export interface ClusterSettings {
        /**
         * List of string arguments passed to the Node.js executable.
         * @default process.execArgv
         */
        execArgv?: string[] | undefined;
        /**
         * File path to worker file.
         * @default process.argv[1]
         */
        exec?: string | undefined;
        /**
         * String arguments passed to worker.
         * @default process.argv.slice(2)
         */
        args?: string[] | undefined;
        /**
         * Whether or not to send output to parent's stdio.
         * @default false
         */
        silent?: boolean | undefined;
        /**
         * Configures the stdio of forked processes. Because the cluster module relies on IPC to function, this configuration must
         * contain an `'ipc'` entry. When this option is provided, it overrides `silent`. See [`child_prcess.spawn()`](https://nodejs.org/docs/latest-v22.x/api/child_process.html#child_processspawncommand-args-options)'s
         * [`stdio`](https://nodejs.org/docs/latest-v22.x/api/child_process.html#optionsstdio).
         */
        stdio?: any[] | undefined;
        /**
         * Sets the user identity of the process. (See [`setuid(2)`](https://man7.org/linux/man-pages/man2/setuid.2.html).)
         */
        uid?: number | undefined;
        /**
         * Sets the group identity of the process. (See [`setgid(2)`](https://man7.org/linux/man-pages/man2/setgid.2.html).)
         */
        gid?: number | undefined;
        /**
         * Sets inspector port of worker. This can be a number, or a function that takes no arguments and returns a number.
         * By default each worker gets its own port, incremented from the primary's `process.debugPort`.
         */
        inspectPort?: number | (() => number) | undefined;
        /**
         * Specify the kind of serialization used for sending messages between processes. Possible values are `'json'` and `'advanced'`.
         * See [Advanced serialization for `child_process`](https://nodejs.org/docs/latest-v22.x/api/child_process.html#advanced-serialization) for more details.
         * @default false
         */
        serialization?: SerializationType | undefined;
        /**
         * Current working directory of the worker process.
         * @default undefined (inherits from parent process)
         */
        cwd?: string | undefined;
        /**
         * Hide the forked processes console window that would normally be created on Windows systems.
         * @default false
         */
        windowsHide?: boolean | undefined;
    }
    export interface Address {
        address: string;
        port: number;
        /**
         * The `addressType` is one of:
         *
         * * `4` (TCPv4)
         * * `6` (TCPv6)
         * * `-1` (Unix domain socket)
         * * `'udp4'` or `'udp6'` (UDPv4 or UDPv6)
         */
        addressType: 4 | 6 | -1 | "udp4" | "udp6";
    }
    /**
     * A `Worker` object contains all public information and method about a worker.
     * In the primary it can be obtained using `cluster.workers`. In a worker
     * it can be obtained using `cluster.worker`.
     * @since v0.7.0
     */
    export class Worker extends EventEmitter {
        /**
         * Each new worker is given its own unique id, this id is stored in the `id`.
         *
         * While a worker is alive, this is the key that indexes it in `cluster.workers`.
         * @since v0.8.0
         */
        id: number;
        /**
         * All workers are created using [`child_process.fork()`](https://nodejs.org/docs/latest-v22.x/api/child_process.html#child_processforkmodulepath-args-options), the returned object
         * from this function is stored as `.process`. In a worker, the global `process` is stored.
         *
         * See: [Child Process module](https://nodejs.org/docs/latest-v22.x/api/child_process.html#child_processforkmodulepath-args-options).
         *
         * Workers will call `process.exit(0)` if the `'disconnect'` event occurs
         * on `process` and `.exitedAfterDisconnect` is not `true`. This protects against
         * accidental disconnection.
         * @since v0.7.0
         */
        process: child.ChildProcess;
        /**
         * Send a message to a worker or primary, optionally with a handle.
         *
         * In the primary, this sends a message to a specific worker. It is identical to [`ChildProcess.send()`](https://nodejs.org/docs/latest-v22.x/api/child_process.html#subprocesssendmessage-sendhandle-options-callback).
         *
         * In a worker, this sends a message to the primary. It is identical to `process.send()`.
         *
         * This example will echo back all messages from the primary:
         *
         * ```js
         * if (cluster.isPrimary) {
         *   const worker = cluster.fork();
         *   worker.send('hi there');
         *
         * } else if (cluster.isWorker) {
         *   process.on('message', (msg) => {
         *     process.send(msg);
         *   });
         * }
         * ```
         * @since v0.7.0
         * @param options The `options` argument, if present, is an object used to parameterize the sending of certain types of handles.
         */
        send(message: child.Serializable, callback?: (error: Error | null) => void): boolean;
        send(
            message: child.Serializable,
            sendHandle: child.SendHandle,
            callback?: (error: Error | null) => void,
        ): boolean;
        send(
            message: child.Serializable,
            sendHandle: child.SendHandle,
            options?: child.MessageOptions,
            callback?: (error: Error | null) => void,
        ): boolean;
        /**
         * This function will kill the worker. In the primary worker, it does this by
         * disconnecting the `worker.process`, and once disconnected, killing with `signal`. In the worker, it does it by killing the process with `signal`.
         *
         * The `kill()` function kills the worker process without waiting for a graceful
         * disconnect, it has the same behavior as `worker.process.kill()`.
         *
         * This method is aliased as `worker.destroy()` for backwards compatibility.
         *
         * In a worker, `process.kill()` exists, but it is not this function;
         * it is [`kill()`](https://nodejs.org/docs/latest-v22.x/api/process.html#processkillpid-signal).
         * @since v0.9.12
         * @param [signal='SIGTERM'] Name of the kill signal to send to the worker process.
         */
        kill(signal?: string): void;
        destroy(signal?: string): void;
        /**
         * In a worker, this function will close all servers, wait for the `'close'` event
         * on those servers, and then disconnect the IPC channel.
         *
         * In the primary, an internal message is sent to the worker causing it to call `.disconnect()` on itself.
         *
         * Causes `.exitedAfterDisconnect` to be set.
         *
         * After a server is closed, it will no longer accept new connections,
         * but connections may be accepted by any other listening worker. Existing
         * connections will be allowed to close as usual. When no more connections exist,
         * see `server.close()`, the IPC channel to the worker will close allowing it
         * to die gracefully.
         *
         * The above applies _only_ to server connections, client connections are not
         * automatically closed by workers, and disconnect does not wait for them to close
         * before exiting.
         *
         * In a worker, `process.disconnect` exists, but it is not this function;
         * it is `disconnect()`.
         *
         * Because long living server connections may block